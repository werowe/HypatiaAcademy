# -*- coding: utf-8 -*-
"""SG.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rHyH4ru9qxS_GW3G4i9Nmjvdoyrbn4_Z
"""

import requests
from operator import itemgetter
import pandas as pd



def assign_value(faction):
    first_letter = faction[0].lower()
    if first_letter == 'v':
        return 0
    elif first_letter == 'i':
        return 1
    else:
        return 2


def assign_value(league):
    first_letter = league[0].lower()
    if first_letter == 'm':
        return 3
    elif first_letter == 'd':
        return 2
    elif first_letter == 'p':
        return 1
    else:
      return 0

def least_squared_error(array1, array2):
    if len(array1) != len(array2):
        raise ValueError("Arrays must be of the same length")
    differences = np.subtract(array1, array2)
    squared_differences = np.square(differences)
    lse = np.sum(squared_differences)
    return lse


x = requests.get('https://api.stormgate.untapped.gg/api/v1/leaderboard?match_mode=ranked_1v1')

data = x.json()

df = pd.DataFrame(data)
df.index = df.index + 1
df



df['race'] = df['race'].apply(lambda x: assign_value(x))
df['league'] = df['league'].apply(lambda x: assign_value(x))
df


b = 1500
x1 = df['losses']
m1 = 0
x2 = df['wins']
m2 = 0
x3 = (ratio['winrate']-0.5)
m3 = 1500

y = b + x1*m1 + x2*m2 + x3*m3
yreal = df[['mmr']]
yreal = yreal.squeeze()
print(y)
print(yreal)



squarederrorLeast = 9999999999999 #There is definitely way better ways of making an upper limit, but for the sake of simplicity I did it like this for now.

for i in range(0, 10000): #Finding whether winrate has any affect on your mmr
    y = b + x1*m1 + x2*m2 + x3*i
    squarederrorActual = least_squared_error(y, yreal)
    if (squarederrorActual<squarederrorLeast):
      squarederrorLeast = squarederrorActual
      m3 = i

print(squarederrorLeast)
for i in np.arange(-5, 5, 0.01): #Finding whether wins count has any affect on your mmr
    y = b + x1*m1 + x2*i + x3*m3
    squarederrorActual = least_squared_error(y, yreal)
    if (squarederrorActual<squarederrorLeast):
      squarederrorLeast = squarederrorActual
      m2 = i

print(squarederrorLeast)
for i in np.arange(-5, 5, 0.1): #Finding whether loses count has any affect on your mmr
    y = b + x1*i + x2*m2 + x3*m3
    squarederrorActual = least_squared_error(y, yreal)
    if (squarederrorActual<squarederrorLeast):
      squarederrorLeast = squarederrorActual
      m1 = i

print(squarederrorActual)
print(squarederrorLeast)
print(m3, m2, m1)



